<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>The life of residuals</title>
    <meta name="description" content="A visual guide to model diagnostics" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="./style.css" />
    <link rel="stylesheet" href="./scrollama.css" />
  </head>

  <body>
    <main>
      <section id="intro">
        <h1 class="intro__hed">The life of residuals</h1>
        <p class="intro__sub">A visual guide to model diagnostics</p>
        <p class="intro__body">
          Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
        </p>
        <p class="intro__exit">
          Start scrolling to begin.
        </p>
      </section>

      <section id="scrolly">
        <article>
          <div class="step" data-step="0">
            <p>STEP 0</p>
          </div>
          <div class="step" data-step="1">
            <p>STEP 1</p>
          </div>
          <div class="step" data-step="2">
            <p>STEP 2</p>
          </div>
          <div class="step" data-step="3">
            <p>STEP 3</p>
          </div>
          <div class="step" data-step="4">
            <p>STEP 4</p>
          </div>
          <div class="step" data-step="5">
            <p>STEP 5</p>
          </div>
          <div class="step" data-step="6">
            <p>STEP 6</p>
          </div>
          <div class="step" data-step="7">
            <p>STEP 7</p>
          </div>
        </article>

        <figure>
          <img class="figure__intro" src="https://allisonhorst.github.io/palmerpenguins/reference/figures/culmen_depth.png">
          <svg class="canvas" id="canvas1" viewBox="0,0, 1000, 1000"></svg>
          <p id="step-id">0</p>
        </figure>
      </section>

      <section id="outro"></section>
    </main>

    <!-- <div class='debug'></div> -->
    <script src="./d3.min.js"></script>
    <script src="./intersection-observer.js"></script>
    <script src="./stickyfill.min.js"></script>
    <script src="./scrollama.min.js"></script>
    <script src="./data.js"></script>
    <script>
      // using d3 for convenience
      const main = d3.select("main");
      const scrolly = main.select("#scrolly");
      const figure = scrolly.select("figure");
      const figureIntro = figure.select(".figure__intro")
      const article = scrolly.select("article");
      const step = article.selectAll(".step");
      const stepID = figure.select("#step-id")


      // D3 plotting code
      const width = 1000
      const height = 1000
      const canvasList = d3.selectAll(".canvas")
      const canvas1 = d3.select("#canvas1")

      const draw = {}
      draw.canvas1 = function() {

        const plot = canvas1

        const dims = {
          width: width,
          height: height,
          margin: {t: height / 40, r: 0, b: height / 15, l: 0}
        }
        dims.panel = {
          width: dims.width - dims.margin.r - dims.margin.l,
          height: dims.height - dims.margin.t - dims.margin.b
        }

        // compute scales, helpers, position constants
        function expand(domain) {
          const range = domain[1] - domain[0]
          const expansion = range * 0.05
          return [domain[0] - expansion, domain[1] + expansion]
        }

        const xScale = d3
          .scaleLinear()
          .domain(expand(d3.extent(data, d => d.predictor)))
          .range([0, dims.panel.width])
          .nice()
        const xDomain = xScale.domain()
        
        const yScale = d3
          .scaleLinear()
          .domain(expand(d3.extent(data, d => d.observed)))
          .range([dims.panel.height, 0])
          .nice()
        const averageY = yScale(d3.mean(data, d => d.observed))

        //// for 1D stage
        const residAbsMax = d3.max(data, d => Math.abs(d.residual))
        const xScale1D = d3.scaleLinear()
          .domain([-residAbsMax, residAbsMax])
          .range([0, dims.panel.width])
          .nice()

        const resid_zAbsMax = d3.max(data, d => Math.abs(d.residual_z))
        const x_zScale1D = d3.scaleLinear()
          .domain([-resid_zAbsMax, resid_zAbsMax])
          .range([0, dims.panel.width])
          .nice()
        
        const histGen = d3.histogram()
          .value(d => d.residual)
          .domain(x_zScale1D.domain())
          .thresholds(dims.panel.width / 100)
        const histData = histGen(data)
        const yScaleHist = d3.scaleLinear()
          .domain([0, d3.max(histData, d => d.length)])
          .range([dims.panel.height * 3/4, dims.panel.height * 1/4])
          .nice()
        const histBand = x_zScale1D(histData[0].x1) - x_zScale1D(histData[0].x0)
        const histPadding = histBand * 0.05

        // draw layers

        const panel = plot.append("g")
          .classed("panel", true)
          .style("transform", `translate(${dims.margin.l}px, ${dims.margin.t}px)`)

        const geoms = panel.append("g")
          .classed("geoms", true)

        // regression line
        const lmLine = geoms.append("line")
          .classed("lm-line", true)
          .attr("x1", xScale(xDomain[0]))
          .attr("y1", yScale(model.predict(xDomain[0])))
          .attr("x2", xScale(xDomain[1]))
          .attr("y2", yScale(model.predict(xDomain[1])))
          .attr("stroke", "steelblue")

        // data points
        const pointsG = geoms.append("g")
          .classed("points", true)
          .selectAll(".point-g")
          .data(data)
          .join("g")
          .classed("point-g", true)
          .style(
            "transform",
            (d) => `translate(
            ${xScale(d.predictor)}px,
            ${yScale(d.observed)}px)`
          )

        // residual as difference
        const residualLine = pointsG
          .selectAll("line")
          .data(d => [d])
          .join("line")
            .classed("residual-line", true)
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("x2", 0)
            .attr("y2", d => yScale(d.fitted) - yScale(d.observed))
            .attr("stroke", d => d.residual > 0 ? "green" : "red")

        // observed points
        const points = pointsG
          .append("circle")
          .classed("observed-point", true)
          .attr("r", 6)
          .attr("fill", "black")
          .attr("stroke", "white")
        
        // residual annotations
        const residualText = pointsG
          .append("text")
          .classed("residual-text", true)
          .attr("dx", (d) => (d.residual > 0 ? "2em" : "-2em"))
          .attr("dy", "0.35em")
          .text((d) => {
            const residual = d3.format(".2f")(d.residual);
            return (residual > 0 ? "+" : "") + residual;
          })
          .style("fill", (d) => d.residual > 0 ? "green" : "red")
          
        // residual points
        const residualPoint = geoms
          .append("g")
            .classed("residual-points", true)
          .selectAll(".residual-point")
          .data(data)
          .join("circle")
            .classed("residual-point", true)
            .attr("cx", d => xScale1D(d.residual))
            .attr("cy", averageY - 20)
            .attr("r", 10)
            .attr("fill", "black")
            .attr("stroke", "white")
            .attr("stroke-width", 2)

        // residual histogram
        const residualBar = geoms
          .append("g")
            .classed("residual-bars", true)
          .selectAll(".residual-bar")
          .data(histData)
          .join("rect")
            .classed("residual-bar", true)
            .attr("x", d => x_zScale1D(d.x0) + histPadding)
            .attr("y", d => yScaleHist(0))
            .attr("width", d => x_zScale1D(d.x1) - x_zScale1D(d.x0) - histPadding * 2)
            .attr("fill", "#789FBC")

        // draw axes
        const xAxis = panel.append("g")
            .classed("axis", true)
            .style("transform", `translate(0px, ${dims.panel.height}px)`)
            .call(d3.axisBottom(xScale).ticks(dims.panel.width / 100))
            .call(g => {
              g.append("text")
                .style("font-size", "22px")
                .attr("text-anchor", "end")
                .attr("x", dims.panel.width)
                .attr("dy", "-1.5em")
                .text("Body Mass (g) →")
              g.selectAll(".tick text")
                .attr("dy", "1em")
            })

        const yAxis = panel.append("g")
            .classed("axis", true)
            .call(d3.axisLeft(yScale).ticks(dims.panel.height / 80))
            .call(g => {
              g.append("text")
                .style("font-size", "22px")
                .style("transform", "rotate(90deg)")
                .style("text-anchor", "start")
                .attr("dy", "-1.5em")
                .text("← Bill Length (mm)")
              g.selectAll(".tick text")
                .attr("dx", "-0.2em")
            })

        const xAxis1D = panel.append("g")
          .classed("axis", true)
          .style("transform", `translate(0px, ${averageY}px)`)
          .call(d3.axisBottom(xScale1D).ticks(dims.panel.width / 100))
        const xAxis1DTitle = xAxis1D.append("text")
          .style("font-size", "22px")
          .attr("text-anchor", "middle")
          .attr("x", dims.panel.width / 2)
          .attr("dy", "3em")
          .text("Residuals")

        const yAxisHist = panel.append("g")
          .classed("axis", true)
          .call(d3.axisLeft(yScaleHist).ticks(dims.panel.width / 200))

        // init trnasparent state
        lmLine.style("opacity", 0)
        residualLine.style("stroke-dasharray", "0,1")
        residualText.style("opacity", 0)
        xAxis1D.style("opacity", 0)
        yAxisHist.style("opacity", 0)
        residualPoint.style("opacity", 0)
        residualBar.attr("height", 0)

        // functions triggered on step enter/exit
        return {
          step0(direction) {
            if (direction == "down") {

            } else {
              figureIntro
                .transition()
                .duration(1000)
                .style("opacity", 1)
              canvas1.style("opacity", 0)
              stepID.style("opacity", 0)
            }
          },
          step1(direction) {
            if (direction == "down") {
              figureIntro
                .transition()
                .duration(1000)
                .style("opacity", 0)

              canvas1.style("opacity", 1)
              stepID.style("opacity", 1)
            } else {
              lmLine
                .transition()
                .duration(500)
                .style("opacity", 0)
            }
          },
          step2(direction) {
            if (direction === "down") {
              lmLine
                .transition()
                .duration(1000)
                .style("opacity", 1)
            } else {
              residualLine
                .transition()
                .duration(700)
                .styleTween("stroke-dasharray", function () {
                  const length = this.getTotalLength();
                  return d3.interpolate(`${length},${length}`, `0,${length}`);
                })
            }
          },
          step3(direction) {
            if (direction === "down") {
              residualLine
                .transition()
                .duration(1000)
                .styleTween("stroke-dasharray", function () {
                  const length = this.getTotalLength();
                  return d3.interpolate(`0,${length}`, `${length},${length}`);
                })
            } else {
              lmLine.interrupt()
                .attr("y1", yScale(model.predict(xDomain[0])))
                .attr("y2", yScale(model.predict(xDomain[1])))
                .style("opacity", 1)
              pointsG.interrupt()
              .style(
                "transform",
                (d) => `translate(
                ${xScale(d.predictor)}px,
                ${yScale(d.observed)}px)`
              )

              residualText
                .transition()
                .duration(600)
                .style("opacity", 0)
            }
          },
          step4(direction) {
            if (direction === "down") {
              residualText
                .transition()
                .delay((d, i) => 30 * i)
                .style("opacity", 1)
            } else {

              const t = plot.transition().duration(700).ease(d3.easeQuadOut)

              xAxis
                .transition(t)
                .style("opacity", 1)
              yAxis
                .transition(t)
                .style("opacity", 1)

              lmLine
                .transition(t)
                .attr("y1", yScale(model.predict(xDomain[0])))
                .attr("y2", yScale(model.predict(xDomain[1])))
                .style("opacity", 1)

              pointsG.interrupt()
                .transition(t)
                .style(
                  "transform",
                  (d) => `translate(
                  ${xScale(d.predictor)}px,
                  ${yScale(d.observed)}px)`
                )
                
              points.interrupt().style("opacity", 1)
              residualText.interrupt().style("opacity", 1)
              residualLine.interrupt().style("stroke-dasharray", "none")
              xAxis1D.interrupt().style("opacity", 0)
              residualPoint.interrupt().style("opacity", 0)

            }
          },
          step5(direction) {
            if (direction === "down") {

              const t1 = plot.transition().duration(1000)
              const t2 = t1.transition().duration(1200)
              const t3 = t2.transition().duration(800)

              // 1st transition

              xAxis
                .transition(t1)
                .style("opacity", 0)
              yAxis
                .transition(t1)
                .style("opacity", 0)

              lmLine
                .transition(t1)
                .attr("y1", averageY)
                .attr("y2", averageY)
                .style("opacity", 0)

              pointsG
                .transition(t1)
                .style(
                  "transform",
                  (d) => `translate(
                  ${xScale(d.predictor)}px,
                  ${yScale(d.observed) - (yScale(d.fitted) - averageY)}px)`
                )

              points
                .transition(t1)
                .style("opacity", 0)
              residualText
                .transition(t1)
                .style("opacity", 0)
              
              // 2nd transition

              xAxis1D
                .transition(t2)
                .style("opacity", 1)

              pointsG
                .transition(t2)
                .ease(d3.easeCubicOut)
                .style(
                  "transform",
                  (d) => `translate(
                  ${xScale1D(d.residual)}px,
                  ${yScale(d.observed) - (yScale(d.fitted) - averageY)}px)`
                )

              // 3rd transition

              residualLine
                .transition(t3)
                .styleTween("stroke-dasharray", function () {
                  const length = this.getTotalLength();
                  return d3.interpolate(`0, 0, ${length}, 0`, `0, ${length}, ${length}, 0`);
                })              

              residualPoint
                .transition(t3)
                .style("opacity", 0.5)

            } else {

              residualPoint.interrupt()
                .attr("cy", averageY - 30)
                .style("opacity", 0.5)
              xAxis1D.interrupt()
                .style("transform", `translate(0px, ${averageY}px`)
              residualBar.interrupt()
                .attr("height", 0)
              
              const t = plot.transition().duration(500)

              xAxis1D
                .transition(t)
                .call(d3.axisBottom(xScale1D).ticks(dims.panel.width / 100))

              xAxis1DTitle
                .style("opacity", 0)
                .transition(t)
                .ease(d3.easeSinOut)
                .style("opacity", 1)
                .text("Residuals")

            }
          },
          step6(direction) {
            if (direction == "down") {

              xAxis1D.interrupt()
                .style("opacity", 1)
              residualPoint.interrupt()
                .style("opacity", 0.5)
              pointsG.interrupt()
                .style(
                  "transform",
                  (d) => `translate(
                  ${xScale1D(d.residual)}px,
                  ${yScale(d.observed) - (yScale(d.fitted) - averageY)}px)`
                )
              residualLine.interrupt()
                .style("stroke-dasharray", "0, 1")

              const t = plot.transition().duration(1000)

              xAxis1D
                .transition(t)
                .call(d3.axisBottom(x_zScale1D))

              xAxis1DTitle
                .style("opacity", 0)
                .transition(t)
                .ease(d3.easeSinOut)
                .style("opacity", 1)
                .text("Residuals (z-scored)")

            } else {

              const t1 = plot.transition().duration(500)
              const t2 = t1.transition().duration(500)

              residualBar
                .transition(t1)
                .attr("y", yScaleHist(0))
                .attr("height", 0)
              
              residualPoint
                .transition(t2)
                .attr("cy", averageY - 30)
                .style("opacity", 0.5)

              xAxis1D
                .transition(t2)
                .style("transform", `translate(0px, ${averageY}px`)

              yAxisHist
                .transition(t1)
                .style("opacity", 0)

            }
          },
          step7(direction) {
            if (direction == "down") {
              
              const t1 = plot.transition().duration(1000)
              const t2 = t1.transition().duration(1000)

              // 1st transition

              xAxis1D
                .transition(t1)
                .style("opacity", 1)
                .style("transform", `translate(0px, ${dims.panel.height * 3/4}px)`)

              residualPoint
                .transition(t1)
                .attr("cy", yScaleHist(0))
                .style("opacity", 0)

              // 2nd transition

              yAxisHist
                .transition(t2)
                .style("opacity", 1)

              //// transition y and height simultaneously for grow from baseline
              residualBar
                .transition(t2)
                .ease(d3.easeQuadOut)
                .attr("y", d => yScaleHist(d.length))
                .attr("height", d => yScaleHist(0) - yScaleHist(d.length))

            } else {

            }
          }
        }

      }()


      // initialize the scrollama
      const scroller = scrollama();

      // generic window resize listener event
      function handleResize() {
        // 1. update height of step elements
        const stepH = Math.floor(window.innerHeight * 1);
        const stepPadding = stepH * 0.8
        const stepMargin = stepH * 0.8

        step
          .style("height", stepH + 'px')
          .style("padding-bottom", stepPadding + 'px')
          .style("margin-bottom", stepMargin + 'px')
         

        const figureHeight = window.innerHeight * 0.9;
        const figureMarginTop = (window.innerHeight - figureHeight) / 2;

        figure
          .style("height", figureHeight + "px")
          .style("top", figureMarginTop + "px");

        // 3. tell scrollama to update new element dimensions
        scroller.resize();
      }

      // scrollama event handlers
      function handleStepEnter(response) {
        console.log(response);
        // response = { element, direction, index }

        // add color to current step only
        step.classed("is-active", function(d, i) {
          return i === response.index;
        });
        

        // main behavior
        draw["canvas" + 1]["step" + response.index](response.direction)



        // update graphic based on step
        figure.select("p").text(response.index);
      }

      function setupStickyfill() {
        d3.selectAll(".sticky").each(function() {
          Stickyfill.add(this);
        });
      }

      function init() {
        setupStickyfill();

        // 1. force a resize on load to ensure proper dimensions are sent to scrollama
        handleResize();

        // 2. setup the scroller passing options
        // 		this will also initialize trigger observations
        // 3. bind scrollama event handlers (this can be chained like below)
        scroller
          .setup({
            step: "#scrolly article .step",
            offset: 0.6,
            debug: true
          })
          .onStepEnter(handleStepEnter);

        // setup resize event
        window.addEventListener("resize", handleResize);
      }

      // kick things off
      init();
    </script>

    <style> 
      text {
        fill: black;
        font-family: Open Sans;
      }
      .axis {
        font-size: 18px;
      }
      .lm-line {
        stroke-width: 4px;
      }
      .residual-line {
        stroke-width: 3px;
      }
      .residual-text {
        font-size: 20px;
        stroke: white;
        stroke-width: 5px;
        text-anchor: middle;
        paint-order: stroke;
      }
    </style>
  </body>
</html>